# 적정주가와 투자 매력 등급을 계산·요약해 출력
from pykrx import stock                       # 모듈/패키지 import 문법: pykrx 패키지에서 stock 서브모듈만 가져옴
import datetime as dt                         # as 별칭: datetime 모듈을 dt라는 이름으로 사용
import pandas as pd                           # 관례적 별칭: pandas→pd
import numpy as np                            # 관례적 별칭: numpy→np
import requests, io, zipfile, xml.etree.ElementTree as ET  # 콤마로 여러 모듈 동시 import, as로 별칭
import re                                     # 정규표현식 모듈

API_KEY = "32ba89ca15f1fde1cb7116b4e08b2959c861f4e4"  
# ── 회사명/코드 변환 (stock_code, corp_code)
def get_codes(target: str):                   # 함수 정의 def, 매개변수에 타입힌트(: str)
    url = "https://opendart.fss.or.kr/api/corpCode.xml"  # 지역변수 할당
    z = zipfile.ZipFile(                      # zipfile.ZipFile: ZIP 파일 열기
        io.BytesIO(                           # io.BytesIO: 바이트 스트림을 파일처럼 다룸
            requests.get(                     # requests.get: HTTP GET 호출
                url, params={"crtfc_key": API_KEY}, timeout=15  # 쿼리스트링 dict, 타임아웃 초 단위
            ).content                         # Response.content: 바이너리 응답 바디
        )
    )                                        
    root = ET.fromstring(                     # XML 문자열을 Element 트리로 파싱
        z.read(z.namelist()[0])               # z.namelist(): ZIP 내부 파일명 리스트, [0] 첫 파일
    )
    rows = [                                  # 리스트 내포(list comprehension): 반복하며 dict 생성
        {
            "corp_name": (e.findtext("corp_name") or "").strip(),   # .findtext: 하위태그 텍스트, None 대비 or "", .strip 공백제거
            "stock_code": (e.findtext("stock_code") or "").strip(), # 6자리 종목코드(비상장일 수 있어 빈문자열 가능)
            "corp_code":  (e.findtext("corp_code") or "").strip()   # DART 내부 8자리 법인코드
        }
        for e in root.findall(".//list")       # .findall: XPath 유사 선택자, 모든 <list> 요소 반복
    ]
    df = pd.DataFrame(rows)                    # 판다스 DataFrame 생성(행 리스트 → 테이블)
    target = target.strip()                    # 문자열 메서드 .strip(): 양쪽 공백 제거
    if re.fullmatch(r"\d{6}", target):         # 정규식 완전일치: 6자리 숫자면 종목코드로 간주
        hit = df[df["stock_code"] == target]   # 불리언 인덱싱: 조건으로 행 선택
    else:
        hit = df[df["corp_name"] == target]    # 회사명 완전일치 먼저 시도
        if hit.empty:                          # DataFrame.empty: 행이 없으면 True
            hit = df[df["corp_name"].str.contains(target, na=False)]  # 부분일치: .str.contains, na=False로 NaN 제외
    if hit.empty or hit.iloc[0]["stock_code"] == "":  # .iloc[0]: 첫 행, or로 두 조건 중 하나라도 참이면
        raise ValueError("해당 상장사를 찾을 수 없습니다.")  # 예외 발생(프로그램 중단)
    r = hit.iloc[0]                             # 첫 매칭 행을 시리즈로 추출
    return r["stock_code"], r["corp_code"]      # 다중 반환(tuple): (종목코드, 법인코드)

# ── 분석 기준일: 종목 PER>0 그리고 시장 avg PER>0 인 최근일
def find_analysis_day(code, days=60):          # 최근 60일(약 2개월) 안에서 유효한 거래일을 찾음
    today = dt.datetime.now()                  # 현재 날짜시간 객체(now는 클래스 메서드)
    for d in range(days):                      # for-range 반복: 0..days-1
        day = (today - dt.timedelta(days=d)).strftime("%Y%m%d")  # 날짜 뺄셈(timedelta), strftime 포맷팅
        qd = stock.get_nearest_business_day_in_a_week(day)       # pykrx 유틸: 입력일자 기준 가장 가까운 영업일 문자열

        fund = stock.get_market_fundamental_by_date(qd, qd, code)  # 해당일의 단일 종목 펀더멘털 조회
        if fund.empty:                           # 빈 DF면 다음 반복으로 continue
            continue
        per = pd.to_numeric(                     # 안전형 변환: 숫자/문자 → float, 변환불가시 NaN
            fund["PER"].iloc[0], errors="coerce" # 첫 행의 "PER" 값
        )
        if not (pd.notna(per) and per > 0):      # pd.notna: NaN 아님, and 논리연산, per>0 양수 확인
            continue

        ind = stock.get_market_fundamental_by_ticker(qd, market="ALL")  # 그날 전체 종목 지표. ind:
        if ind.empty or "PER" not in ind.columns:  # 컬럼 존재성 검사
            continue
        ind_per = pd.to_numeric(ind["PER"], errors="coerce")            # 전체 PER를 수치로 변환
        ind_per = ind_per[(ind_per > 0) & ind_per.notna()]              # 불리언 마스크 결합(&): 양수이면서 NaN 아님
        if ind_per.empty:                                               # 유효 표본 없으면
            continue

        return qd                                # 조건 만족하는 가장 최근 영업일을 즉시 반환
    # 못 찾으면 오늘 영업일
    return stock.get_nearest_business_day_in_a_week(  
        dt.datetime.now().strftime("%Y%m%d")
    )

# ── DART 매출액 CAGR
def sales_cagr(corp_code: str, years: int = 6):  # 매개변수에 타입힌트 및 기본값(int)
    this_year = dt.datetime.now().year           # .year 속성: 정수 연도
    names = ["매출액","수익(매출액)","수익","Revenue","매출","영업수익(매출액)",
             "영업수익","매출수익","매출고","Sales"]  # 리스트 리터럴(여러 후보명)
    vals = []                                     # 빈 리스트 초기화(연도,값) 쌍 저장
    for y in range(this_year, this_year - (years + 2), -1):  # 역순 range: 올해→과거
        url = "https://opendart.fss.or.kr/api/fnlttSinglAcntAll.json"  # DART 단일계정 API
        p = { "crtfc_key": API_KEY, "corp_code": corp_code,            # dict 리터럴(쿼리파라미터)
              "bsns_year": str(y), "reprt_code": "11011" }             # str(y): 정수→문자열
        data = requests.get(url, params=p, timeout=15).json()          # .json(): JSON→파이썬 dict
        lst = data.get("list") or []            # dict.get 기본값, or []로 None 대비
        if not lst:                             # 빈 리스트면 False로 평가 → if not
            continue
        df = pd.DataFrame(lst)                  # 리스트(dict들)→DataFrame
        df = df[df["sj_div"].isin(["IS","CIS","IS2","CIS2"])]  # .isin: 다중값 필터(손익계산서만)
        pick = None                             # 선택값 초기화(None: 값 없음의 표준)
        for nm in names:                        # 후보명 순회
            hit = df[(df["fs_div"]=="CFS") & df["account_nm"].str.contains(nm, na=False)]  # 연결재무제표 우선
            if hit.empty:                       # 없으면
                hit = df[(df["fs_div"]=="OFS") & df["account_nm"].str.contains(nm, na=False)]  # 별도재무제표
            if not hit.empty:                   # 하나라도 찾으면
                pick = hit.iloc[0]; break       # 첫 행 선택; 세미콜론으로 같은 줄에 2문장 가능, break로 for 탈출
        if pick is not None:                    # None 체크
            s = re.sub(r"[^0-9.\-]", "", str(pick["thstrm_amount"]) or "")  # re.sub로 숫자/점/마이너스만 남김
            if s not in ("", "-", "."):         # 빈/의미없는 값 필터
                vals.append((y, float(s)))      # float 변환 후 튜플 추가

    vals = sorted(set(vals))                    # set으로 중복 제거 후 sorted로 정렬(연도 오름차순)
    if len(vals) < 2:                           # 최소 2점(시작/끝) 필요
        return np.nan                           # numpy NaN 반환
    y0, v0 = vals[0]; y1, v1 = vals[-1]        # 시퀀스 언패킹: 첫 요소, 마지막 요소
    if v0 <= 0 or v1 <= 0:                      # 분모/분자 양수 조건
        return np.nan
    n = max(1, y1 - y0)                         # 0 나눗셈 방지: 최소 1년
    return (v1 / v0) ** (1 / n) - 1             # CAGR 공식: (끝/시작)^(1/년수) - 1

# ── 메인
target = input("분석할 종목명 또는 코드 입력: ").strip()  # input: 콘솔 입력 받기, .strip 공백 제거
code, corp_code = get_codes(target)                # 다중 할당: 튜플 (code, corp_code) 언패킹
qdate = find_analysis_day(code, days=60)           # 키워드 인자(days=60) 전달

price = int(                                        # int(): 정수 변환
    stock.get_market_ohlcv_by_date(qdate, qdate, code)["종가"].iloc[0]  # 시계열 DF에서 컬럼→첫 값
)
fund = stock.get_market_fundamental_by_date(qdate, qdate, code).iloc[0] # 단일행 DataFrame을 시리즈로

PER = pd.to_numeric(fund.get("PER"), errors="coerce")  # dict-like .get: 키 없을 때 None, 숫자 변환
EPS = pd.to_numeric(fund.get("EPS"), errors="coerce")
BPS = pd.to_numeric(fund.get("BPS"), errors="coerce")

# EPS<=0 이면 ROE는 N/A로 표시
if pd.notna(EPS) and pd.notna(BPS) and BPS and BPS > 0 and EPS > 0:  # 다중 조건 and, 0/None은 False로 평가
    ROE = float(EPS / BPS * 100)                                     # 산술연산, float 강제
else:
    ROE = np.nan                                                     # NaN 지정

cagr = sales_cagr(corp_code)                                         # 함수 호출, 반환값 저장
sales_growth = round(cagr * 100, 1) if pd.notna(cagr) else np.nan    # 조건부 표현식(삼항연산자), round(소수1자리)

ind = stock.get_market_fundamental_by_ticker(qdate, market="ALL")    # 같은 날 전체 종목 지표
ind_per = pd.to_numeric(ind["PER"], errors="coerce")                 # 시리즈를 수치로 변환
ind_per = ind_per[(ind_per > 0) & ind_per.notna()]                   # 불리언 마스크 결합(&)
avg_per = ind_per.mean() if not ind_per.empty else np.nan            # if-else 표현식: 평균 또는 NaN

fair = round(price * (avg_per / PER)) if (pd.notna(PER) and PER > 0 and pd.notna(avg_per) and avg_per > 0) else None
# 위 한 줄: 조건부 표현식으로 적정가 산출 또는 None

def valu_txt(px, fv):                                    # 함수 정의(지역 스코프)
    if fv is None: return "평가 불가"                    # 단일 라인 return(조기 반환)
    diff = round((fv - px) / px * 100, 1)                # 괴리율(%) 계산
    if diff > 10: return f"{diff}% 저평가 구간"          # f-string: 표현식 삽입형 포맷
    if diff > 0:  return f"{diff}% 소폭 저평가"
    if diff > -10:return f"{abs(diff)}% 소폭 고평가"     # abs: 절댓값
    return f"{abs(diff)}% 고평가 구간"

val_comment = valu_txt(price, fair)                      # 함수 호출, 반환 문자열 저장
grade = (                                                # 괄호로 여러 줄 표현(연산자 우선)
    "중상" if (pd.notna(ROE) and ROE >= 10) and (pd.notna(sales_growth) and sales_growth >= 5)
    else "보통" if (pd.notna(ROE) and ROE >= 7) or (pd.notna(sales_growth) and sales_growth >= 3)
    else "하"                                           # 중첩 삼항(조건부 표현식)으로 등급 분기
)

# 출력
print(f"\n[분석 대상] {target} ({code})")                # \n 줄바꿈, f-string 포맷
print(f"\n[분석 기준일] {qdate}")                        # 변수 삽입 출력
print(f"현재가 {price:,.0f}원 / 적정가 {(f'{fair:,.0f}원' if fair else '산출불가')}")  
# :,.0f 포맷 지정자: 천단위 콤마, 소수 0자리 / 내부 f-string을 또 f-string으로 넣는 중첩 표현
print(f"→ 동종 업종 평균 대비 {val_comment}")           # 화살표 기호와 문자열 연결
print(
    f"→ ROE {(f'{ROE:.1f}%' if pd.notna(ROE) else 'N/A')}
