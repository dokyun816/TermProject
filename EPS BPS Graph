# ==== pykrx로 주식수 확보 → EPS/BPS 계산 → 간단 예측치 산출 ====
import re, datetime as dt                # 정규식(re), 날짜/시간 처리(datetime) 모듈 임포트
import numpy as np, pandas as pd         # 수치연산용 NumPy, 표 형태 데이터 처리용 Pandas
import matplotlib.pyplot as plt          # 시각화(그래프)용 Matplotlib
from matplotlib.ticker import FuncFormatter  # y축 눈금 형식 지정용 포매터
import pykrx       # 한국거래소, 네이버 증권 데이터 불러오는 라이브러리

# --------------------------
# 0) 유틸
def _num(x):
    if x is None: return np.nan          # None이면 NaN으로 통일
    if isinstance(x, (int, float, np.number)): return float(x)  # 숫자형이면 float로 변환
    # 문자열 안의 숫자/부호/소수점만 남기고 숫자로 강제 변환 (쉼표, 단위, 공백 제거)
    return pd.to_numeric(re.sub(r"[^\d\-\.+]", "", str(x)), errors="coerce")

# --------------------------
# 1) pykrx: 상장주식수
def _recent_trading_day():
    from pykrx import stock              # 함수 내부 임포트(모듈 미설치 환경 대비/지연 로딩)
    d = dt.date.today()                  # 오늘 날짜 기준으로
    for _ in range(10):                  # 최대 10일 거슬러 올라가며
        s = d.strftime("%Y%m%d")         # 'YYYYMMDD' 문자열로 변환
        # 해당 날짜가 거래일이면 시가총액 데이터가 비어있지 않음 → 이 날짜를 사용
        if not stock.get_market_cap_by_date(s, s, "005930").empty:
            return s
        d -= dt.timedelta(days=1)        # 전날로 한 칸 이동(주말·공휴일 스킵 목적)
    return d.strftime("%Y%m%d")          # 마지막으로 확인한 날짜 반환(방어용)

def get_listed_shares_by_pykrx(code: str) -> int:
    from pykrx import stock              # pykrx 임포트
    day = _recent_trading_day()          # 가장 최근 거래일 찾기
    df = stock.get_market_cap_by_date(day, day, code)  # 해당일의 시가총액/상장주식수 테이블
    if df.empty:                         # 비어 있으면 예외 처리
        raise ValueError("KRX 데이터 비어 있음")
    return int(df.iloc[0]["상장주식수"])  # 첫 행의 '상장주식수' 컬럼 값을 정수로 반환

# --------------------------
# 2) DART 표에서 연도별 항목 뽑기
#    all_df: ['year' or 'bsns_year', 'account_nm', 'thstrm_amount']
def _pick_yearly(df: pd.DataFrame, names: list[str]) -> pd.Series:
    if df.empty or "account_nm" not in df: return pd.Series(dtype=float)  # 기본 검증
    base = df[df["account_nm"].notna()].copy()      # 계정명 결측 제거
    base["year"] = base.get("year", base.get("bsns_year"))  # 'year'가 없으면 'bsns_year' 사용
    if base["year"] is None or base["year"].isna().all():   # 연도 정보 없으면 빈 시리즈
        return pd.Series(dtype=float)

    # 찾을 계정명 패턴(대소문자 무시) 구성: 예) '당기순이익|분기순이익|...'
    pat = "|".join(map(lambda s: re.escape(s.casefold()), names))
    # 계정명에 위 패턴이 포함된 행만 필터링
    sub = base[base["account_nm"].astype(str).str.casefold().str.contains(pat, na=False)].copy()
    if sub.empty: return pd.Series(dtype=float)     # 없으면 빈 시리즈

    sub["thstrm_amount"] = sub["thstrm_amount"].map(_num)   # 금액을 숫자형으로 정규화
    sub["year"] = pd.to_numeric(sub["year"], errors="coerce")# 연도 숫자화
    sub = sub.dropna(subset=["thstrm_amount","year"])       # 핵심 컬럼 결측 제거
    if sub.empty: return pd.Series(dtype=float)

    sub["abs_amount"] = sub["thstrm_amount"].abs()  # 동일 연도에 중복 계정이 있으면 절댓값 큰 것 우선
    # 연도 오름차순, 금액 절댓값 내림차순으로 정렬 후, 연도별 첫 행만 선택
    pick = (sub.sort_values(["year","abs_amount"], ascending=[True, False])
              .groupby("year", as_index=False).first())
    # 인덱스: 연도(int), 값: 'thstrm_amount'으로 시리즈 구성 후 연도 기준 정렬
    return pd.Series(pick["thstrm_amount"].values, index=pick["year"].astype(int)).sort_index()

# --------------------------
# 3) EPS/BPS 계산
def build_eps_bps(all_df: pd.DataFrame, shares) -> pd.DataFrame:
    sh = _num(shares)                                    # 주식수 숫자화
    if all_df.empty or pd.isna(sh) or sh <= 0:           # 입력 검증
        return pd.DataFrame()
    # 당기순이익/총포괄손익 계정에서 연도별 금액 시리즈 추출 (연결 기준도 포괄)
    ni = _pick_yearly(all_df, ["당기순이익","분기순이익","반기순이익","당기순손익","연결총포괄손익"])
    # 자본총계/지배주주지분에서 연도별 금액 시리즈 추출
    eq = _pick_yearly(all_df, ["자본총계","지배기업의소유주지분"])
    years = sorted(set(ni.index) | set(eq.index))        # 두 시리즈의 연도 합집합
    if not years: return pd.DataFrame()                  # 연도가 하나도 없으면 종료
    out = pd.DataFrame(index=years, dtype=float)         # 연도를 인덱스로 결과 DF 생성
    if not ni.empty: out["EPS"] = ni / sh                # EPS = 당기순이익 / 상장주식수
    if not eq.empty: out["BPS"] = eq / sh                # BPS = 자본총계 / 상장주식수
    return out

# --------------------------
# 4) 간단 예측치
#    - EPS: 선형회귀(연도→EPS)로 1~k년 앞 예측
#    - BPS: 과거 CAGR로 1~k년 앞 예측
def forecast_eps_bps(eps_bps: pd.DataFrame, years_ahead: int = 1) -> pd.DataFrame:
    if eps_bps.empty: return pd.DataFrame()              # 히스토리 없으면 예측 불가
    idx_years = eps_bps.index.astype(int).to_numpy()     # 연도 인덱스를 정수 배열로
    fut_years = np.arange(idx_years.max() + 1, idx_years.max() + 1 + years_ahead)  # 예측 연도 범위

    # 예측 결과를 담을 DF(컬럼: EPS_pred, BPS_pred)
    out = pd.DataFrame(index=fut_years, columns=["EPS_pred","BPS_pred"], dtype=float)

    # EPS: 최소 2개 연도 이상이 있어야 1차 회귀 가능
    if "EPS" in eps_bps and eps_bps["EPS"].notna().sum() >= 2:
        x = idx_years[eps_bps["EPS"].notna()]           # 결측 아닌 연도만 사용
        y = eps_bps.loc[x, "EPS"].to_numpy()            # 해당 연도의 EPS 값
        m, b = np.polyfit(x, y, 1)                      # 1차 다항(직선) 회귀: y = m*x + b
        out["EPS_pred"] = m * fut_years + b             # 미래 연도에 회귀선 대입

    # BPS: CAGR(복리성장률) 기반 추정 (최소 2개 연도 필요)
    if "BPS" in eps_bps and eps_bps["BPS"].notna().sum() >= 2:
        bps = eps_bps["BPS"].dropna()                   # 결측 제거
        y0, yN = int(bps.index.min()), int(bps.index.max())  # 첫 해, 마지막 해
        n = yN - y0                                     # 경과 연수
        if n > 0 and bps.loc[y0] > 0:                   # 분모 0 방지 및 기간 확인
            cagr = (bps.loc[yN] / bps.loc[y0]) ** (1/n) - 1  # CAGR 계산
            last_bps = bps.loc[yN]                      # 최근년도 BPS
            # 1~k년까지 CAGR을 누적 적용하여 예측치 생성
            preds = [last_bps * ((1 + cagr) ** t) for t in range(1, years_ahead + 1)]
            out["BPS_pred"] = preds

    return out                                          # 예측 DF 반환

# --------------------------
# 5) 간단 플롯
# --------------------------
def plot_eps_bps_with_forecast(hist: pd.DataFrame, fc: pd.DataFrame):
    fmt = FuncFormatter(lambda y,_: f"{y:,.0f}")        # y축 숫자를 천단위 콤마/정수로 표시

    def _plot_one(col, title):
        plt.figure(figsize=(8,4.5))                     # 그림 크기
        if col in hist and hist[col].notna().any():     # 히스토리 존재 시
            y = hist[col].dropna(); x = y.index.astype(int)  # 연도와 값
            plt.plot(x, y.values, marker="o", label=f"{col} (hist)")  # 실선 히스토리
        if not fc.empty and f"{col}_pred" in fc and fc[f"{col}_pred"].notna().any():
            y2 = fc[f"{col}_pred"].dropna(); x2 = y2.index.astype(int)  # 예측 연도와 값
            plt.plot(x2, y2.values, marker="o", linestyle="--", label=f"{col} (pred)")  # 점선 예측
        plt.title(title); plt.xlabel("연도"); plt.ylabel("원/주")   # 제목/축 레이블
        plt.grid(True); plt.gca().yaxis.set_major_formatter(fmt) # 격자와 y축 포맷
        plt.legend(); plt.tight_layout(); plt.show()     # 범례/레이아웃/표시

    _plot_one("EPS", "EPS 추이 및 예측 (원/주)")         # EPS 그래프
    _plot_one("BPS", "BPS 추이 및 예측 (원/주)")         # BPS 그래프

# --------------------------
# 6) 실행 예시
if __name__ == "__main__":                               # 스크립트 직접 실행 시 동작
    stock_code = input("종목코드 (예: 005930): ").strip() # 사용자로부터 종목코드 입력

    # pykrx로 상장주식수만 확보
    try:
        shares = get_listed_shares_by_pykrx(stock_code)  # KRX에서 상장주식수 조회
    except ModuleNotFoundError:
        raise SystemExit("[오류] pykrx 미설치: pip install pykrx")  # 미설치 가이드
    except Exception as e:
        raise SystemExit(f"[오류] 상장주식수 조회 실패: {e}")        # 기타 실패 메시지

    # all_df는 DART API로 가져온 실제 재무제표를 넣으세요.
    # 아래는 테스트용 더미 (pandas 2.x: concat 사용)
    df_profit = pd.DataFrame({                           # 예시: 연도별 당기순이익(원)
        "year":[2021,2022,2023],
        "account_nm":["당기순이익"]*3,
        "thstrm_amount":[1.0e11, 1.2e11, 0.9e11]
    })
    df_equity = pd.DataFrame({                           # 예시: 연도별 자본총계(원)
        "year":[2021,2022,2023],
        "account_nm":["자본총계"]*3,
        "thstrm_amount":[2.3e13, 2.5e13, 2.7e13]
    })
    all_df = pd.concat([df_profit, df_equity], ignore_index=True)  # 두 표를 하나로 결합

    eps_bps = build_eps_bps(all_df, shares)              # EPS/BPS 계산
    print("[EPS/BPS]\n", eps_bps)                        # 계산 결과 출력

    # 1년치 예측(원하면 years_ahead 변경)
    fc = forecast_eps_bps(eps_bps, years_ahead=1)        # 간단 예측(EPS 회귀 / BPS CAGR)
    print("\n[예측치]\n", fc)                            # 예측 결과 출력

    plot_eps_bps_with_forecast(eps_bps, fc)              # 히스토리+예측 그래프 출력
