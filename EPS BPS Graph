# 표준 라이브러리 & 외부 라이브러리 임포트
import os, io, zipfile, re, requests, pandas as pd, xml.etree.ElementTree as ET  # 파일, 네트워킹, 데이터 처리, XML 파싱
from bs4 import BeautifulSoup  # HTML 파싱(Selector 기반)
from io import StringIO  # ← 추가: 문자열 형태의 HTML을 판다스 read_html로 읽을 때 사용

# OpenDART API 인증키 (금융감독원 API 사용 시 필요)
API_KEY = "32ba89ca15f1fde1cb7116b4e08b2959c861f4e4"

# ── 회사명 -> 종목코드 (DART corpCode.xml)
def _corp_df():
    # DART에서 corpCode.xml(zip) 다운로드 URL
    url = "https://opendart.fss.or.kr/api/corpCode.xml"
    # HTTP GET으로 zip 파일 바이트 수신 후 ZipFile로 오픈 (timeout=15초)
    z = zipfile.ZipFile(io.BytesIO(requests.get(url, params={"crtfc_key": API_KEY}, timeout=15).content))
    # zip 안의 첫 번째 파일이 corpCode.xml 이므로 바로 읽어서 파싱
    root = ET.fromstring(z.read(z.namelist()[0]))
    # XML의 <list> 요소들에서 회사명/종목코드 추출 → 딕셔너리 리스트 구성
    rows = [{"corp_name": e.findtext("corp_name"),
             "stock_code": (e.findtext("stock_code") or "").strip()}
            for e in root.findall(".//list")]
    # 판다스 DataFrame으로 변환하여 반환
    return pd.DataFrame(rows)

# DART 기업코드 캐시 (최초 1회만 네트워크 호출하기 위함)
_CORP = None

def resolve_code(s: str) -> tuple[str, str]:
    # 사용자 입력 전후 공백 제거
    s = s.strip()
    # 만약 6자리 숫자(정규식 매칭)면 이미 종목코드로 보고 그대로 반환 (회사명은 임시로 종목코드와 동일 값 반환)
    if re.fullmatch(r"\d{6}", s):
        return s, s
    # API_KEY 필수 안내 (여기선 이미 상단에 고정되어 있으므로 통과)
    if not API_KEY:
        raise ValueError("회사명 매핑에는 DART_API_KEY가 필요합니다. (6자리 종목코드 입력 가능)")
    # 전역 DataFrame 로딩 (최초 1회만 _corp_df 호출)
    global _CORP
    if _CORP is None:
        _CORP = _corp_df()
    # 회사명 부분일치(case-insensitive)로 검색
    hit = _CORP[_CORP["corp_name"].str.contains(s, case=False, na=False)]
    # 종목코드가 비어 있는(비상장 등) 행 제거
    hit = hit[hit["stock_code"] != ""]
    # 첫 번째 매칭 결과 선택 (※ 매칭 실패 시 IndexError 가능 → 실전에서는 예외처리 권장)
    row = hit.iloc[0]
    # (종목코드, 회사명) 튜플 반환
    return row["stock_code"], row["corp_name"]

# ── 숫자 파싱
def _num(x):
    try:
        # 문자열에서 천단위 콤마와 '원' 제거 후 float 변환
        return float(str(x).replace(",", "").replace("원", "").strip())
    except:
        # 변환 불가 시 None 반환 (향후 계산 단계에서 None 체크)
        return None

# ── PER/PBR 연간표(최근 5년) - 표 인덱스 의존 제거 + StringIO 적용
def per_pbr_5y(code: str) -> pd.DataFrame:
    # 네이버 금융 종목 메인 페이지 HTML 요청 (UA 지정으로 차단 회피)
    html = requests.get(f"https://finance.naver.com/item/main.nhn?code={code}",
                        headers={"User-Agent": "Mozilla/5.0"}, timeout=15).text
    # 페이지 내 모든 테이블을 순회하며 PER/PBR이 있는 표를 탐색
    for df in pd.read_html(StringIO(html)):  # ← 수정: 문자열을 파일처럼 읽게 해줌
        # 열이 2개 미만인 표는 의미 없으므로 스킵
        if df.shape[1] < 2:
            continue
        # 컬럼명을 문자형 리스트로 정규화
        cols = [str(c) for c in df.columns]
        # 표 복사 후 첫 열을 '항목'으로 강제 지정 (인덱스 의존성 제거)
        tmp = df.copy()
        tmp.columns = ["항목"] + cols[1:]
        # '항목' 열에 PER 또는 PBR 문자열이 없으면 스킵
        if not tmp["항목"].astype(str).str.contains("PBR|PER", na=False).any():
            continue
        # 연도처럼 보이는(숫자 문자열) 컬럼만 추출
        year_cols = [c for c in tmp.columns[1:] if str(c).isdigit()]
        if not year_cols:
            continue
        # '항목' + 연도열만 남김
        tmp = tmp.loc[:, ["항목"] + year_cols]
        # 'PER'가 포함된 행의 연도별 수치만 슬라이스
        per = tmp[tmp["항목"].astype(str).str.contains("PER", na=False)].iloc[0, 1:]
        # 'PBR'가 포함된 행의 연도별 수치만 슬라이스
        pbr = tmp[tmp["항목"].astype(str).str.contains("PBR", na=False)].iloc[0, 1:]
        # DataFrame 구성 후 숫자 변환(에러는 NaN), NaN 행 제거
        out = pd.DataFrame({
            "PER": pd.to_numeric(per, errors="coerce"),
            "PBR": pd.to_numeric(pbr, errors="coerce")
        }).dropna()
        # 인덱스 이름을 '연도'로 명시
        out.index.name = "연도"
        # 최근 5개 연도만 반환
        return out.tail(5)
    # 적합한 표를 못 찾으면 빈 DataFrame 반환 (PER/PBR 열만 사전정의)
    return pd.DataFrame(columns=["PER", "PBR"])

# ── 현재 스냅샷(EPS/BPS/현재가/시총) — 시총 None 보호
def snapshot(code: str) -> dict:
    # 네이버 금융 종목 페이지 HTML 요청
    html = requests.get(f"https://finance.naver.com/item/main.nhn?code={code}",
                        headers={"User-Agent": "Mozilla/5.0"}, timeout=15).text
    # BeautifulSoup으로 파싱
    s = BeautifulSoup(html, "lxml")
    # 현재가: p.no_today 아래 .blind 텍스트(숫자)
    price_el = s.select_one("p.no_today .blind")
    price = _num(price_el.text) if price_el else None
    # 시가총액: id="_market_sum" (네이버는 억원 단위 숫자를 제공)
    mktcap_el = s.select_one("#_market_sum")
    mktcap = _num(mktcap_el.text) if mktcap_el else None
    # 단위 변환: 억원 → 원
    # ※ 이 줄 때문에 결과가 '시가총액(원)'이 됨. 억원 표시를 원하시면 이 줄을 제거하세요.
    if mktcap is not None:
        mktcap *= 1e8  # 네이버는 억원 단위
    # EPS/BPS: 재무 테이블에서 항목명 검색 후 오른쪽 셀 값 파싱
    eps = bps = None
    for tr in s.select("table.per_table tr"):
        # 각 행의 th, td 텍스트를 리스트로 수집
        cells = [t.get_text(strip=True) for t in tr.select("th,td")]
        # 'EPS' 또는 'BPS'라는 키워드가 있는 셀의 오른쪽 값을 취함
        for i, v in enumerate(cells):
            if "EPS" in v and i + 1 < len(cells):
                eps = _num(cells[i + 1]) or eps
            if "BPS" in v and i + 1 < len(cells):
                bps = _num(cells[i + 1]) or bps
    # 현재가/시총/EPS/BPS를 딕셔너리로 반환
    return {"price": price, "mktcap": mktcap, "EPS": eps, "BPS": bps}

# ── 실행
# 사용자에게 회사명 또는 6자리 종목코드 입력 받기
user = input("회사명 또는 6자리 종목코드를 입력하세요: ").strip()
# 입력값을 종목코드/회사명으로 정규화
code, name = resolve_code(user)
# 최근 5년 PER/PBR 표 수집
hist = per_pbr_5y(code)
# 현재 스냅샷(가격/시총/EPS/BPS) 수집
snap = snapshot(code)

# 5년 평균 PER/PBR (히스토리가 비어 있으면 None)
avgPER = hist["PER"].mean() if not hist.empty else None
avgPBR = hist["PBR"].mean() if not hist.empty else None
# EPS/BPS 값 언패킹
eps, bps = snap["EPS"], snap["BPS"]

# 적정가(PER) = (5년평균 PER) × EPS
tp_per = (avgPER * eps) if (avgPER and eps) else None
# 적정가(PBR) = (5년평균 PBR) × BPS
tp_pbr = (avgPBR * bps) if (avgPBR and bps) else None

# 결과 요약 테이블(DataFrame) 구성
summary = pd.DataFrame({
    "종목": [name],
    "코드": [code],
    "현재가": [snap["price"]],       # 원 단위
    "시가총액(원)": [snap["mktcap"]],  # 위에서 억→원 변환했기 때문에 '원'이 맞음
    "EPS(원)": [eps],
    "BPS(원)": [bps],
    "5년평균 PER": [None if avgPER is None else round(avgPER, 2)],
    "5년평균 PBR": [None if avgPBR is None else round(avgPBR, 2)],
    "적정가(PER)": [None if tp_per is None else round(tp_per, 0)],
    "적정가(PBR)": [None if tp_pbr is None else round(tp_pbr, 0)]
})

# 표 출력 형식 지정 (천 단위 콤마, 소수점 등)
display(summary.style.format({
    "현재가": "{:,.0f}",
    "시가총액(원)": "{:,.0f}",  # 원 단위 금액 포맷
    "EPS(원)": "{:,.0f}",
    "BPS(원)": "{:,.0f}",
    "5년평균 PER": "{:,.2f}",
    "5년평균 PBR": "{:,.2f}",
    "적정가(PER)": "{:,.0f}",
    "적정가(PBR)": "{:,.0f}"
}))

# PER/PBR 히스토리가 있으면 연도 오름차순으로 함께 출력
if not hist.empty:
    display(hist.rename_axis("연도").sort_index())
